diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..ae9ee76
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,23 @@
+*.o
+*.a
+*.out
+Makefile
+
+buildpkg.sh
+config.h
+config.log
+config.status
+openssh.xml
+opensshd.init
+scp
+sftp
+sftp-server
+ssh
+ssh-add
+ssh-agent
+ssh-keygen
+ssh-keyscan
+ssh-keysign
+ssh-pkcs11-helper
+sshd
+survey.sh
diff --git a/Makefile.in b/Makefile.in
index d401787..78f48c7 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -92,7 +92,7 @@ LIBSSH_OBJS=${LIBOPENSSH_OBJS} \
 	kex.o kexdh.o kexgex.o kexecdh.o kexc25519.o \
 	kexdhc.o kexgexc.o kexecdhc.o kexc25519c.o \
 	kexdhs.o kexgexs.o kexecdhs.o kexc25519s.o \
-	platform-pledge.o
+	platform-pledge.o obfuscate.o
 
 SSHOBJS= ssh.o readconf.o clientloop.o sshtty.o \
 	sshconnect.o sshconnect1.o sshconnect2.o mux.o
@@ -246,7 +246,7 @@ distclean:	regressclean
 	rm -f *.o *.a $(TARGETS) logintest config.cache config.log
 	rm -f *.out core opensshd.init openssh.xml
 	rm -f Makefile buildpkg.sh config.h config.status
-	rm -f survey.sh openbsd-compat/regress/Makefile *~ 
+	rm -f survey.sh openbsd-compat/regress/Makefile *~
 	rm -rf autom4te.cache
 	rm -f regress/unittests/test_helper/*.a
 	rm -f regress/unittests/test_helper/*.o
diff --git a/kex.c b/kex.c
index d371f47..e1c0599 100644
--- a/kex.c
+++ b/kex.c
@@ -359,9 +359,12 @@ kex_send_newkeys(struct ssh *ssh)
 	debug("SSH2_MSG_NEWKEYS sent");
 	debug("expecting SSH2_MSG_NEWKEYS");
 	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_input_newkeys);
-	if (ssh->kex->ext_info_c)
+	if (ssh->kex->ext_info_c) {
+		sshpkt_disable_obfuscation();
 		if ((r = kex_send_ext_info(ssh)) != 0)
 			return r;
+		sshpkt_enable_obfuscation();
+	}
 	return 0;
 }
 
@@ -421,6 +424,7 @@ kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
 	kex->flags &= ~KEX_INIT_SENT;
 	free(kex->name);
 	kex->name = NULL;
+	sshpkt_disable_obfuscation();
 	return 0;
 }
 
diff --git a/obfuscate.c b/obfuscate.c
new file mode 100644
index 0000000..1faf92b
--- /dev/null
+++ b/obfuscate.c
@@ -0,0 +1,249 @@
+#include "includes.h"
+#include <openssl/evp.h>
+#include <openssl/rc4.h>
+#include <unistd.h>
+#include <string.h>
+#include "atomicio.h"
+#include "canohost.h"
+#include "xmalloc.h"
+#include "log.h"
+#include "obfuscate.h"
+
+static RC4_KEY rc4_input;
+static RC4_KEY rc4_output;
+
+static const char * obfuscate_keyword = NULL;
+
+#define OBFUSCATE_KEY_LENGTH 16
+#define OBFUSCATE_SEED_LENGTH 16
+#define OBFUSCATE_HASH_ITERATIONS 6000
+#define OBFUSCATE_MAX_PADDING 8192
+#define OBFUSCATE_MAGIC_VALUE 0x0BF5CA7E
+
+struct seed_msg {
+	u_char seed_buffer[OBFUSCATE_SEED_LENGTH];
+	u_int32_t magic;
+	u_int32_t padding_length;
+	u_char padding[];
+};
+
+static void generate_key_pair(const u_char *, u_char *, u_char *);
+static void generate_key(const u_char *, const u_char *, u_int, u_char *);
+static void set_keys(const u_char *, const u_char *);
+static void initialize(const u_char *, int);
+static void read_forever(int);
+
+/*
+ * Server calls this
+ */
+void
+obfuscate_receive_seed(int sock_in)
+{
+	struct seed_msg seed;
+
+	u_char padding_drain[OBFUSCATE_MAX_PADDING];
+	u_int len;
+	u_int32_t padding_length;
+
+	len = atomicio(read, sock_in, &seed, sizeof(struct seed_msg));
+
+	debug2(
+		"obfuscate_receive_seed: read %d "
+		"byte seed message from client", len);
+
+	if (len != sizeof(struct seed_msg))
+		fatal("obfuscate_receive_seed: read failed");
+
+	initialize(seed.seed_buffer, 1);
+	obfuscate_input((u_char *)&seed.magic, 8);
+
+	if (OBFUSCATE_MAGIC_VALUE != ntohl(seed.magic)) {
+		logit(
+			"Magic value check failed (%u) on obfuscate handshake "
+			"from %.200s port %d", ntohl(seed.magic),
+			get_remote_ipaddr(), get_remote_port());
+		read_forever(sock_in);
+	}
+	padding_length = ntohl(seed.padding_length);
+	if (padding_length > OBFUSCATE_MAX_PADDING) {
+		logit(
+			"Illegal padding length %d for obfuscated handshake "
+			"from %.200s port %d", ntohl(seed.padding_length),
+			get_remote_ipaddr(), get_remote_port());
+		read_forever(sock_in);
+	}
+	len = atomicio(read, sock_in, padding_drain, padding_length);
+	if (len != padding_length)
+		fatal("obfuscate_receive_seed: read failed");
+	debug2(
+		"obfuscate_receive_seed: read %d bytes of padding from client.",
+		len);
+	obfuscate_input(padding_drain, padding_length);
+}
+
+/*
+ * Client calls this
+ */
+void
+obfuscate_send_seed(int sock_out)
+{
+	struct seed_msg *seed;
+	int i;
+	u_int32_t rnd = 0;
+	u_int message_length;
+	u_int padding_length;
+
+	u_int32_t start = arc4random();
+
+	padding_length = start % OBFUSCATE_MAX_PADDING;
+	message_length = padding_length + sizeof(struct seed_msg);
+	seed = xmalloc(message_length);
+
+	for (i = 0; i < OBFUSCATE_SEED_LENGTH; i++) {
+		if (i % 4 == 0)
+			rnd = arc4random();
+		seed->seed_buffer[i] = rnd & 0xff;
+		rnd >>= 8;
+	}
+	seed->magic = htonl(OBFUSCATE_MAGIC_VALUE);
+	seed->padding_length = htonl(padding_length);
+	for (i = 0; i < (int)padding_length; i++) {
+		if (i % 4 ==0)
+			rnd = arc4random();
+		seed->padding[i] = rnd & 0xff;
+	}
+	initialize(seed->seed_buffer, 0);
+	obfuscate_output(
+		((u_char *)seed) + OBFUSCATE_SEED_LENGTH,
+		message_length - OBFUSCATE_SEED_LENGTH);
+	debug2(
+		"obfuscate_send_seed: Sending seed message with %u "
+		"bytes of padding", padding_length);
+	atomicio(vwrite, sock_out, seed, message_length);
+	free(seed);
+}
+
+
+void
+obfuscate_set_keyword(const char * keyword)
+{
+	debug2(
+		"obfuscate_set_keyword: Setting obfuscation "
+		"keyword to '%s'", keyword);
+	obfuscate_keyword = keyword;
+}
+
+
+void
+obfuscate_input(u_char *buffer, u_int buffer_len)
+{
+	RC4(&rc4_input, buffer_len, buffer, buffer);
+}
+
+
+void
+obfuscate_output(u_char *buffer, u_int buffer_len)
+{
+	RC4(&rc4_output, buffer_len, buffer, buffer);
+}
+
+
+static void
+initialize(const u_char *seed, int server)
+{
+	u_char client_to_server_key[OBFUSCATE_KEY_LENGTH];
+	u_char server_to_client_key[OBFUSCATE_KEY_LENGTH];
+
+	generate_key_pair(seed, client_to_server_key, server_to_client_key);
+
+	if (server)
+		set_keys(client_to_server_key, server_to_client_key);
+	else
+		set_keys(server_to_client_key, client_to_server_key);
+}
+
+
+static void
+generate_key_pair(
+	const u_char *seed,
+	u_char *client_to_server_key,
+	u_char *server_to_client_key)
+{
+	generate_key(
+		seed, (const u_char *)"client_to_server",
+		strlen("client_to_server"), client_to_server_key);
+	generate_key(
+		seed, (const u_char *)"server_to_client",
+		strlen("server_to_client"), server_to_client_key);
+}
+
+static void
+generate_key(
+	const u_char *seed, const u_char *iv, u_int iv_len, u_char *key_data)
+{
+	EVP_MD_CTX ctx;
+	u_char md_output[EVP_MAX_MD_SIZE];
+	unsigned int md_len;
+	int i;
+	u_char *buffer;
+	u_char *p;
+	u_int buffer_length;
+
+	buffer_length = OBFUSCATE_SEED_LENGTH + iv_len;
+	if (obfuscate_keyword)
+		buffer_length += strlen(obfuscate_keyword);
+
+	p = buffer = xmalloc(buffer_length);
+
+	memcpy(p, seed, OBFUSCATE_SEED_LENGTH);
+	p += OBFUSCATE_SEED_LENGTH;
+
+	if (obfuscate_keyword) {
+		memcpy(p, obfuscate_keyword, strlen(obfuscate_keyword));
+		p += strlen(obfuscate_keyword);
+	}
+
+	memcpy(p, iv, iv_len);
+
+	EVP_DigestInit(&ctx, EVP_sha1());
+	EVP_DigestUpdate(&ctx, buffer, OBFUSCATE_SEED_LENGTH + iv_len);
+	EVP_DigestFinal(&ctx, md_output, &md_len);
+
+	free(buffer);
+
+	for (i = 0; i < OBFUSCATE_HASH_ITERATIONS; i++) {
+		EVP_DigestInit(&ctx, EVP_sha1());
+		EVP_DigestUpdate(&ctx, md_output, md_len);
+		EVP_DigestFinal(&ctx, md_output, &md_len);
+	}
+
+	if (md_len < OBFUSCATE_KEY_LENGTH)
+		fatal(
+			"Cannot derive obfuscation keys "
+			"from hash length of %u", md_len);
+
+	memcpy(key_data, md_output, OBFUSCATE_KEY_LENGTH);
+}
+
+
+static void
+set_keys(const u_char * input_key, const u_char * output_key)
+{
+	RC4_set_key(&rc4_input, OBFUSCATE_KEY_LENGTH, input_key);
+	RC4_set_key(&rc4_output, OBFUSCATE_KEY_LENGTH, output_key);
+}
+
+
+static void
+read_forever(int sock_in)
+{
+	u_char discard_buffer[1024];
+
+	while (
+		atomicio(
+			read, sock_in,
+			discard_buffer, sizeof(discard_buffer)) > 0)
+		;
+
+	cleanup_exit(255);
+}
diff --git a/obfuscate.h b/obfuscate.h
new file mode 100644
index 0000000..765ed93
--- /dev/null
+++ b/obfuscate.h
@@ -0,0 +1,9 @@
+#ifndef _OBFUSCATE_H
+#define _OBFUSCATE_H
+
+void obfuscate_receive_seed(int);
+void obfuscate_send_seed(int);
+void obfuscate_set_keyword(const char *);
+void obfuscate_input(u_char *, u_int);
+void obfuscate_output(u_char *, u_int);
+#endif
diff --git a/packet.c b/packet.c
index f406c07..3561bea 100644
--- a/packet.c
+++ b/packet.c
@@ -38,7 +38,7 @@
  */
 
 #include "includes.h"
- 
+
 #include <sys/param.h>	/* MIN roundup */
 #include <sys/types.h>
 #include "openbsd-compat/sys-queue.h"
@@ -83,6 +83,7 @@
 #include "channels.h"
 #include "ssh.h"
 #include "packet.h"
+#include "obfuscate.h"
 #include "ssherr.h"
 #include "sshbuf.h"
 
@@ -170,6 +171,8 @@ struct session_state {
 	/* Set to true if we are authenticated. */
 	int after_authentication;
 
+	int obfuscation;
+
 	int keep_alive_timeouts;
 
 	/* The maximum time that we will wait to send or receive a packet */
@@ -838,6 +841,8 @@ ssh_packet_set_encryption_key(struct ssh *ssh, const u_char *key, u_int keylen,
 		error("Warning: %s", wmsg);
 		state->cipher_warning_done = 1;
 	}
+	if (state->obfuscation)
+		sshpkt_disable_obfuscation();
 #endif /* WITH_SSH1 */
 }
 
@@ -914,6 +919,8 @@ ssh_packet_send1(struct ssh *ssh)
 	    sshbuf_ptr(state->outgoing_packet),
 	    sshbuf_len(state->outgoing_packet), 0, 0)) != 0)
 		goto out;
+	if (state->obfuscation)
+		obfuscate_output(cp, sshbuf_len(state->outgoing_packet));
 
 #ifdef PACKET_DEBUG
 	fprintf(stderr, "encrypted: ");
@@ -1261,6 +1268,8 @@ ssh_packet_send2_wrapped(struct ssh *ssh)
 		if ((r = sshbuf_put(state->output, macbuf, mac->mac_len)) != 0)
 			goto out;
 	}
+	if (state->obfuscation)
+		obfuscate_output(cp, sshbuf_len(state->outgoing_packet));
 #ifdef PACKET_DEBUG
 	fprintf(stderr, "encrypted: ");
 	sshbuf_dump(state->output, stderr);
@@ -1549,6 +1558,8 @@ ssh_packet_read_poll1(struct ssh *ssh, u_char *typep)
 		return 0;
 
 	/* The entire packet is in buffer. */
+	if (state->obfuscation)
+		obfuscate_input(buffer_ptr(state->input), padded_len);
 
 	/* Consume packet length. */
 	if ((r = sshbuf_consume(state->input, 4)) != 0)
@@ -1712,6 +1723,8 @@ ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
 		if ((r = sshbuf_reserve(state->incoming_packet, block_size,
 		    &cp)) != 0)
 			goto out;
+		if (state->obfuscation)
+			obfuscate_input(buffer_ptr(state->input), block_size);
 		if ((r = cipher_crypt(&state->receive_context,
 		    state->p_send.seqnr, cp, sshbuf_ptr(state->input),
 		    block_size, 0, 0)) != 0)
@@ -1773,6 +1786,8 @@ ssh_packet_read_poll2(struct ssh *ssh, u_char *typep, u_int32_t *seqnr_p)
 		    macbuf, sizeof(macbuf))) != 0)
 			goto out;
 	}
+	if (state->obfuscation)
+		obfuscate_input(buffer_ptr(state->input), need);
 	if ((r = sshbuf_reserve(state->incoming_packet, aadlen + need,
 	    &cp)) != 0)
 		goto out;
@@ -2972,3 +2987,21 @@ sshpkt_add_padding(struct ssh *ssh, u_char pad)
 	ssh->state->extra_pad = pad;
 	return 0;
 }
+
+void
+sshpkt_enable_obfuscation()
+{
+	debug("Obfuscation enabled");
+	active_state->state->obfuscation = 1;
+}
+
+
+void
+sshpkt_disable_obfuscation()
+{
+	if (active_state != NULL) /* XXX - needed for passing test_kex */
+		if (active_state->state->obfuscation) {
+			debug("Obfuscation disabled");
+			active_state->state->obfuscation = 0;
+		}
+}
diff --git a/packet.h b/packet.h
index 28516a5..5c0cab5 100644
--- a/packet.h
+++ b/packet.h
@@ -159,6 +159,8 @@ int     sshpkt_disconnect(struct ssh *, const char *fmt, ...)
 	    __attribute__((format(printf, 2, 3)));
 int	sshpkt_add_padding(struct ssh *, u_char);
 void	sshpkt_fatal(struct ssh *ssh, const char *tag, int r);
+void sshpkt_enable_obfuscation(void);
+void sshpkt_disable_obfuscation(void);
 
 int	sshpkt_put(struct ssh *ssh, const void *v, size_t len);
 int	sshpkt_putb(struct ssh *ssh, const struct sshbuf *b);
diff --git a/readconf.c b/readconf.c
index b19d13a..1e44285 100644
--- a/readconf.c
+++ b/readconf.c
@@ -132,6 +132,7 @@ typedef enum {
 	oHost, oMatch,
 	oForwardAgent, oForwardX11, oForwardX11Trusted, oForwardX11Timeout,
 	oGatewayPorts, oExitOnForwardFailure,
+	oObfuscateHandshake, oObfuscateKeyword,
 	oPasswordAuthentication, oRSAAuthentication,
 	oChallengeResponseAuthentication, oXAuthLocation,
 	oIdentityFile, oHostName, oPort, oCipher, oRemoteForward, oLocalForward,
@@ -273,6 +274,8 @@ static struct {
 	{ "permitlocalcommand", oPermitLocalCommand },
 	{ "visualhostkey", oVisualHostKey },
 	{ "useroaming", oDeprecated },
+	{ "obfuscatehandshake", oObfuscateHandshake },
+	{ "obfuscatekeyword", oObfuscateKeyword },
 	{ "kexalgorithms", oKexAlgorithms },
 	{ "ipqos", oIPQoS },
 	{ "requesttty", oRequestTTY },
@@ -1575,6 +1578,16 @@ parse_keytypes:
 		    filename, linenum, keyword);
 		return 0;
 
+	case oObfuscateHandshake:
+		intptr = &options->obfuscate_handshake;
+		goto parse_flag;
+
+	case oObfuscateKeyword:
+		if (*activep)
+			options->obfuscate_handshake = 1;
+		charptr = &options->obfuscate_keyword;
+		goto parse_string;
+
 	case oUnsupported:
 		error("%s line %d: Unsupported option \"%s\"",
 		    filename, linenum, keyword);
@@ -1754,6 +1767,8 @@ initialize_options(Options * options)
 	options->update_hostkeys = -1;
 	options->hostbased_key_types = NULL;
 	options->pubkey_key_types = NULL;
+	options->obfuscate_handshake = 0;
+	options->obfuscate_keyword = NULL;
 }
 
 /*
diff --git a/readconf.h b/readconf.h
index 03308aa..ccf1109 100644
--- a/readconf.h
+++ b/readconf.h
@@ -164,6 +164,9 @@ typedef struct {
 	char   *hostbased_key_types;
 	char   *pubkey_key_types;
 
+	int obfuscate_handshake;
+	char *obfuscate_keyword;
+
 	char	*ignored_unknown; /* Pattern list of unknown tokens to ignore */
 }       Options;
 
diff --git a/scp.c b/scp.c
index 8c456d4..c9b0f80 100644
--- a/scp.c
+++ b/scp.c
@@ -397,9 +397,9 @@ main(int argc, char **argv)
 
 	fflag = tflag = 0;
 #ifdef SCTP
-	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q12346S:o:F:z")) != -1)
+	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q12346S:o:F:zZ")) != -1)
 #else
-	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q12346S:o:F:")) != -1)
+	while ((ch = getopt(argc, argv, "dfl:prtvBCc:i:P:q12346S:o:F:zZ")) != -1)
 #endif
 		switch (ch) {
 		/* User-visible flags. */
@@ -408,9 +408,7 @@ main(int argc, char **argv)
 		case '4':
 		case '6':
 		case 'C':
-#ifdef SCTP
 		case 'z':
-#endif
 			addargs(&args, "-%c", ch);
 			addargs(&remote_remote_args, "-%c", ch);
 			break;
@@ -421,6 +419,7 @@ main(int argc, char **argv)
 		case 'c':
 		case 'i':
 		case 'F':
+		case 'Z':
 			addargs(&remote_remote_args, "-%c", ch);
 			addargs(&remote_remote_args, "%s", optarg);
 			addargs(&args, "-%c", ch);
diff --git a/servconf.c b/servconf.c
index 14b0a0f..42802f0 100644
--- a/servconf.c
+++ b/servconf.c
@@ -77,6 +77,7 @@ initialize_server_options(ServerOptions *options)
 
 	/* Standard Options */
 	options->num_ports = 0;
+	options->num_obfuscated_ports = 0;
 	options->ports_from_cmdline = 0;
 	options->queued_listen_addrs = NULL;
 	options->num_queued_listens = 0;
@@ -159,6 +160,7 @@ initialize_server_options(ServerOptions *options)
 	options->num_permitted_opens = -1;
 	options->adm_forced_command = NULL;
 	options->chroot_directory = NULL;
+	options->obfuscate_keyword = NULL;
 	options->authorized_keys_command = NULL;
 	options->authorized_keys_command_user = NULL;
 	options->revoked_keys_file = NULL;
@@ -224,7 +226,7 @@ fill_default_server_options(ServerOptions *options)
 		}
 	}
 	/* No certificates by default */
-	if (options->num_ports == 0)
+	if (options->num_ports == 0 && options->num_obfuscated_ports == 0)
 		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
 	if (options->address_family == -1)
 		options->address_family = AF_UNSPEC;
@@ -401,7 +403,8 @@ typedef enum {
 	/* Portable-specific options */
 	sUsePAM,
 	/* Standard Options */
-	sPort, sHostKeyFile, sServerKeyBits, sLoginGraceTime,
+	sPort, sObfuscatedPort, sObfuscateKeyword,
+	sHostKeyFile, sServerKeyBits, sLoginGraceTime,
 	sKeyRegenerationTime, sPermitRootLogin, sLogFacility, sLogLevel,
 	sRhostsRSAAuthentication, sRSAAuthentication,
 	sKerberosAuthentication, sKerberosOrLocalPasswd, sKerberosTicketCleanup,
@@ -456,6 +459,8 @@ static struct {
 	{ "pamauthenticationviakbdint", sDeprecated, SSHCFG_GLOBAL },
 	/* Standard Options */
 	{ "port", sPort, SSHCFG_GLOBAL },
+	{ "obfuscatedport", sObfuscatedPort, SSHCFG_GLOBAL },
+	{ "obfuscatekeyword", sObfuscateKeyword, SSHCFG_GLOBAL },
 	{ "hostkey", sHostKeyFile, SSHCFG_GLOBAL },
 	{ "hostdsakey", sHostKeyFile, SSHCFG_GLOBAL },		/* alias */
 	{ "hostkeyagent", sHostKeyAgent, SSHCFG_GLOBAL },
@@ -640,9 +645,13 @@ add_listen_addr(ServerOptions *options, char *addr, int port)
 {
 	u_int i;
 
-	if (port == 0)
+	if (port == 0) {
 		for (i = 0; i < options->num_ports; i++)
 			add_one_listen_addr(options, addr, options->ports[i]);
+		for (i = 0; i < options->num_obfuscated_ports; i++)
+			add_one_listen_addr(
+				options, addr, options->obfuscated_ports[i]);
+	}
 	else
 		add_one_listen_addr(options, addr, port);
 }
@@ -696,7 +705,7 @@ process_queued_listen_addrs(ServerOptions *options)
 {
 	u_int i;
 
-	if (options->num_ports == 0)
+	if (options->num_ports == 0 && options->num_obfuscated_ports == 0)
 		options->ports[options->num_ports++] = SSH_DEFAULT_PORT;
 	if (options->address_family == -1)
 		options->address_family = AF_UNSPEC;
@@ -1115,6 +1124,36 @@ process_server_config_line(ServerOptions *options, char *line,
 			    filename, linenum);
 		break;
 
+	case sObfuscatedPort:
+		if (options->ports_from_cmdline)
+			return 0;
+		if (options->listen_addrs != NULL)
+			fatal("%s line %d: ports must be specified "
+				  "before ListenAddress.", filename, linenum);
+		if (options->num_obfuscated_ports >= MAX_PORTS)
+			fatal("%s line %d: too many ports.", filename, linenum);
+		arg = strdelim(&cp);
+		if (!arg || *arg == '\0')
+			fatal("%s line %d: missing port "
+				  "number.", filename, linenum);
+		options->obfuscated_ports[options->num_obfuscated_ports++] =
+			a2port(arg);
+		if (options->obfuscated_ports[options->num_obfuscated_ports - 1]
+			<= 0)
+			fatal("%s line %d: badly formatted "
+				  "port number.", filename, linenum);
+		break;
+
+	case sObfuscateKeyword:
+		charptr = &options->obfuscate_keyword;
+		arg = strdelim(&cp);
+		if (!arg || arg == '\0')
+			fatal("%s line %d: missing keyword "
+				  "argument.", filename, linenum);
+		if (*activep && *charptr == NULL)
+			*charptr = xstrdup(arg);
+		break;
+
 	case sServerKeyBits:
 		intptr = &options->server_key_bits;
  parse_int:
diff --git a/servconf.h b/servconf.h
index 63a0637..328c070 100644
--- a/servconf.h
+++ b/servconf.h
@@ -186,6 +186,11 @@ typedef struct {
 	int	num_permitted_opens;
 
 	char   *chroot_directory;
+
+	int obfuscated_ports[MAX_PORTS];
+	u_int num_obfuscated_ports;
+	char *obfuscate_keyword;
+
 	char   *revoked_keys_file;
 	char   *trusted_user_ca_keys;
 	char   *authorized_keys_command;
diff --git a/sftp.c b/sftp.c
index 2077219..3bbf480 100644
--- a/sftp.c
+++ b/sftp.c
@@ -735,7 +735,7 @@ process_put(struct sftp_conn *conn, char *src, char *dst, char *pwd,
 
                 resume |= global_aflag;
 		if (!quiet && resume)
-			printf("Resuming upload of %s to %s\n", g.gl_pathv[i], 
+			printf("Resuming upload of %s to %s\n", g.gl_pathv[i],
 				abs_dst);
 		else if (!quiet && !resume)
 			printf("Uploading %s to %s\n", g.gl_pathv[i], abs_dst);
@@ -1205,7 +1205,7 @@ makeargv(const char *arg, int *argcp, int sloppy, char *lastquote,
 
 static int
 parse_args(const char **cpp, int *ignore_errors, int *aflag,
-	  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag, 
+	  int *fflag, int *hflag, int *iflag, int *lflag, int *pflag,
 	  int *rflag, int *sflag,
     unsigned long *n_arg, char **path1, char **path2)
 {
@@ -1397,7 +1397,7 @@ parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
     int err_abort)
 {
 	char *path1, *path2, *tmp;
-	int ignore_errors = 0, aflag = 0, fflag = 0, hflag = 0, 
+	int ignore_errors = 0, aflag = 0, fflag = 0, hflag = 0,
 	iflag = 0;
 	int lflag = 0, pflag = 0, rflag = 0, sflag = 0;
 	int cmdnum, i;
@@ -2266,12 +2266,13 @@ main(int argc, char **argv)
 	infile = stdin;
 
 	while ((ch = getopt(argc, argv,
-	    "1246afhpqrvCc:D:i:l:o:s:S:b:B:F:P:R:")) != -1) {
+	    "1246afhpqrvCc:D:i:l:o:s:S:b:B:F:P:R:zZ:")) != -1) {
 		switch (ch) {
 		/* Passed through to ssh(1) */
 		case '4':
 		case '6':
 		case 'C':
+		case 'z':
 			addargs(&args, "-%c", ch);
 			break;
 		/* Passed through to ssh(1) with argument */
@@ -2279,6 +2280,7 @@ main(int argc, char **argv)
 		case 'c':
 		case 'i':
 		case 'o':
+		case 'Z':
 			addargs(&args, "-%c", ch);
 			addargs(&args, "%s", optarg);
 			break;
diff --git a/ssh.c b/ssh.c
index d0d92ce..4dadb80 100644
--- a/ssh.c
+++ b/ssh.c
@@ -205,12 +205,13 @@ static void
 usage(void)
 {
 	fprintf(stderr,
-"usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy" SCTP_OPT "] [-b bind_address] [-c cipher_spec]\n"
+"usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYyz" SCTP_OPT "] [-b bind_address] [-c cipher_spec]\n"
 "           [-D [bind_address:]port] [-E log_file] [-e escape_char]\n"
 "           [-F configfile] [-I pkcs11] [-i identity_file] [-L address]\n"
 "           [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port]\n"
 "           [-Q query_option] [-R address] [-S ctl_path] [-W host:port]\n"
-"           [-w local_tun[:remote_tun]] [user@]hostname [command]\n"
+"           [-w local_tun[:remote_tun]] [-Z obfuscate_keyword]\n"
+"           [user@]hostname [command]\n"
 	);
 	exit(255);
 }
@@ -611,7 +612,7 @@ main(int ac, char **av)
 
  again:
 	while ((opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvx" SCTP_OPT
-	    "ACD:E:F:GI:KL:MNO:PQ:R:S:TVw:W:XYy")) != -1) {
+	    "ACD:E:F:GI:KL:MNO:PQ:R:S:TVw:W:XYyzZ:")) != -1) {
 		switch (opt) {
 		case '1':
 			options.protocol = SSH_PROTO_1;
@@ -850,11 +851,6 @@ main(int ac, char **av)
 			else
 				options.control_master = SSHCTL_MASTER_YES;
 			break;
-#ifdef SCTP
-		case 'z':
-			options.transport = TRANSPORT_SCTP;
-			break;
-#endif
 		case 'p':
 			options.port = a2port(optarg);
 			if (options.port <= 0) {
@@ -930,6 +926,13 @@ main(int ac, char **av)
 		case 'F':
 			config = optarg;
 			break;
+		case 'z':
+			options.obfuscate_handshake = 1;
+			break;
+		case 'Z':
+			options.obfuscate_handshake = 1;
+			options.obfuscate_keyword = optarg;
+			break;
 		default:
 			usage();
 		}
@@ -1044,7 +1047,7 @@ main(int ac, char **av)
 	 * If CanonicalizePermittedCNAMEs have been specified but
 	 * other canonicalization did not happen (by not being requested
 	 * or by failing with fallback) then the hostname may still be changed
-	 * as a result of CNAME following. 
+	 * as a result of CNAME following.
 	 *
 	 * Try to resolve the bare hostname name using the system resolver's
 	 * usual search rules and then apply the CNAME follow rules.
@@ -1481,7 +1484,7 @@ ssh_confirm_remote_forward(int type, u_int32_t seq, void *ctxt)
 			channel_update_permitted_opens(rfwd->handle, -1);
 		}
 	}
-	
+
 	if (type == SSH2_MSG_REQUEST_FAILURE) {
 		if (options.exit_on_forward_failure) {
 			if (rfwd->listen_path != NULL)
@@ -1608,7 +1611,7 @@ ssh_init_forwarding(void)
 			else
 				error("Could not request tunnel forwarding.");
 		}
-	}			
+	}
 }
 
 static void
diff --git a/sshconnect.c b/sshconnect.c
index 21b3f54..c5a09a9 100644
--- a/sshconnect.c
+++ b/sshconnect.c
@@ -62,6 +62,7 @@
 #include "monitor_fdpass.h"
 #include "ssh2.h"
 #include "version.h"
+#include "obfuscate.h"
 #include "authfile.h"
 #include "ssherr.h"
 #include "authfd.h"
@@ -256,6 +257,12 @@ ssh_proxy_connect(const char *host, u_short port, const char *proxy_command)
 	/* Set the connection file descriptors. */
 	packet_set_connection(pout[0], pin[1]);
 
+	if (options.obfuscate_handshake) {
+		if (options.obfuscate_keyword)
+			obfuscate_set_keyword(options.obfuscate_keyword);
+		sshpkt_enable_obfuscation();
+	}
+
 	/* Indicate OK return */
 	return 0;
 }
@@ -555,6 +562,12 @@ ssh_connect_direct(const char *host, struct addrinfo *aitop,
 	/* Set the connection. */
 	packet_set_connection(sock, sock);
 
+	if (options.obfuscate_handshake) {
+		if (options.obfuscate_keyword)
+			obfuscate_set_keyword(options.obfuscate_keyword);
+		sshpkt_enable_obfuscation();
+	}
+
 	return 0;
 }
 
@@ -579,17 +592,28 @@ ssh_connect(const char *host, struct addrinfo *addrs,
 static void
 send_client_banner(int connection_out, int minor1)
 {
+	char buf[256];  // XXX hack necessary for 6.2 upwards
+	u_int sendlen;
 	/* Send our own protocol version identification. */
 	if (compat20) {
-		xasprintf(&client_version_string, "SSH-%d.%d-%.100s\r\n",
+		snprintf(buf, sizeof(buf), "SSH-%d.%d-%.100s\r\n",
 		    PROTOCOL_MAJOR_2, PROTOCOL_MINOR_2, SSH_VERSION);
 	} else {
-		xasprintf(&client_version_string, "SSH-%d.%d-%.100s\n",
+		snprintf(buf, sizeof(buf), "SSH-%d.%d-%.100s\n",
 		    PROTOCOL_MAJOR_1, minor1, SSH_VERSION);
 	}
+	client_version_string = xstrdup(buf);
+	sendlen = strlen(client_version_string);
+	if (options.obfuscate_handshake)
+		obfuscate_output(client_version_string, sendlen);
 	if (atomicio(vwrite, connection_out, client_version_string,
-	    strlen(client_version_string)) != strlen(client_version_string))
+				 sendlen) != sendlen)
 		fatal("write: %.100s", strerror(errno));
+	if (options.obfuscate_handshake) {
+		free(client_version_string);
+		client_version_string = strdup(buf);
+	}
+	memset(buf, 0, sizeof(buf));
 	chop(client_version_string);
 	debug("Local version string %.100s", client_version_string);
 }
@@ -655,6 +679,8 @@ ssh_exchange_identification(int timeout_ms)
 			else if (len != 1)
 				fatal("ssh_exchange_identification: "
 				    "read: %.100s", strerror(errno));
+			if (options.obfuscate_handshake)
+				obfuscate_input(&buf[i], 1);
 			if (buf[i] == '\r') {
 				buf[i] = '\n';
 				buf[i + 1] = 0;
@@ -945,7 +971,7 @@ check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
 		ip_status = check_key_in_hostkeys(ip_hostkeys, host_key,
 		    &ip_found);
 		if (host_status == HOST_CHANGED &&
-		    (ip_status != HOST_CHANGED || 
+		    (ip_status != HOST_CHANGED ||
 		    (ip_found != NULL &&
 		    !key_equal(ip_found->key, host_found->key))))
 			host_ip_differ = 1;
@@ -1211,7 +1237,7 @@ check_host_key(char *hostname, struct sockaddr *hostaddr, u_short port,
 		if (options.exit_on_forward_failure && cancelled_forwarding)
 			fatal("Error: forwarding disabled due to host key "
 			    "check failure");
-		
+
 		/*
 		 * XXX Should permit the user to change to use the new id.
 		 * This could be done by converting the host key to an
@@ -1425,6 +1451,9 @@ ssh_login(Sensitive *sensitive, const char *orighost,
 	host = xstrdup(orighost);
 	lowercase(host);
 
+	if (options.obfuscate_handshake)
+		obfuscate_send_seed(packet_get_connection_out());
+
 	/* Exchange protocol version identification strings with the server. */
 	ssh_exchange_identification(timeout_ms);
 
diff --git a/sshd.c b/sshd.c
index 4ca58ed..3a47561 100644
--- a/sshd.c
+++ b/sshd.c
@@ -121,6 +121,7 @@
 #include "ssh-gss.h"
 #endif
 #include "monitor_wrap.h"
+#include "obfuscate.h"
 #include "ssh-sandbox.h"
 #include "version.h"
 #include "ssherr.h"
@@ -253,6 +254,9 @@ Buffer cfg;
 /* message to be displayed after login */
 Buffer loginmsg;
 
+/* Enable handshake obfuscation */
+int use_obfuscation = 0;
+
 /* Unprivileged user */
 struct passwd *privsep_pw = NULL;
 
@@ -420,6 +424,7 @@ sshd_exchange_identification(int sock_in, int sock_out)
 	char *s, *newline = "\n";
 	char buf[256];			/* Must not be larger than remote_version. */
 	char remote_version[256];	/* Must be at least as big as buf. */
+	u_int sendlen;
 
 	if ((options.protocol & SSH_PROTO_1) &&
 	    (options.protocol & SSH_PROTO_2)) {
@@ -434,19 +439,27 @@ sshd_exchange_identification(int sock_in, int sock_out)
 		minor = PROTOCOL_MINOR_1;
 	}
 
-	xasprintf(&server_version_string, "SSH-%d.%d-%.100s%s%s%s",
+	snprintf(buf, sizeof(buf), "SSH-%d.%d-%.100s%s%s%s",
 	    major, minor, SSH_VERSION,
 	    *options.version_addendum == '\0' ? "" : " ",
 	    options.version_addendum, newline);
+	server_version_string = xstrdup(buf);
+	sendlen = strlen(server_version_string);
+	if (use_obfuscation)
+		obfuscate_output(server_version_string, sendlen);
 
 	/* Send our protocol version identification. */
 	if (atomicio(vwrite, sock_out, server_version_string,
-	    strlen(server_version_string))
-	    != strlen(server_version_string)) {
+				 sendlen) != sendlen) {
 		logit("Could not write ident string to %s", get_remote_ipaddr());
 		cleanup_exit(255);
 	}
 
+	if (use_obfuscation) {
+		free(server_version_string);
+		server_version_string = strdup(buf);
+	}
+
 	/* Read other sides version identification. */
 	memset(buf, 0, sizeof(buf));
 	for (i = 0; i < sizeof(buf) - 1; i++) {
@@ -455,6 +468,8 @@ sshd_exchange_identification(int sock_in, int sock_out)
 			    get_remote_ipaddr());
 			cleanup_exit(255);
 		}
+		if (use_obfuscation)
+			obfuscate_input(&buf[i], 1);
 		if (buf[i] == '\r') {
 			buf[i] = 0;
 			/* Kludge for F-Secure Macintosh < 1.0.2 */
@@ -1596,6 +1611,7 @@ main(int ac, char **av)
 	int sock_in = -1, sock_out = -1, newsock = -1;
 	const char *remote_ip;
 	int remote_port;
+	int local_port;
 	char *fp, *line, *laddr, *logfile = NULL;
 	int config_s[2] = { -1 , -1 };
 	u_int n;
@@ -1723,7 +1739,7 @@ main(int ac, char **av)
 				fprintf(stderr, "too many host keys.\n");
 				exit(1);
 			}
-			options.host_key_files[options.num_host_key_files++] = 
+			options.host_key_files[options.num_host_key_files++] =
 			   derelativise_path(optarg);
 			break;
 		case 't':
@@ -2257,6 +2273,14 @@ main(int ac, char **av)
 	packet_set_connection(sock_in, sock_out);
 	packet_set_server();
 
+	local_port = get_local_port();
+	for (i = 0; i < (int)options.num_obfuscated_ports; i++) {
+		if (options.obfuscated_ports[i] == local_port) {
+			use_obfuscation = 1;
+			break;
+		}
+	}
+
 	/* Set SO_KEEPALIVE if requested. */
 	if (options.tcp_keep_alive && packet_connection_is_on_socket() &&
 	    setsockopt(sock_in, SOL_SOCKET, SO_KEEPALIVE, &on, sizeof(on)) < 0)
@@ -2301,6 +2325,13 @@ main(int ac, char **av)
 	if (!debug_flag)
 		alarm(options.login_grace_time);
 
+	if (use_obfuscation) {
+		if (options.obfuscate_keyword)
+			obfuscate_set_keyword(options.obfuscate_keyword);
+		sshpkt_enable_obfuscation();
+		obfuscate_receive_seed(sock_in);
+	}
+
 	sshd_exchange_identification(sock_in, sock_out);
 
 	/* In inetd mode, generate ephemeral key only for proto 1 connections */
@@ -2322,8 +2353,11 @@ main(int ac, char **av)
 	auth_debug_reset();
 
 	if (use_privsep) {
-		if (privsep_preauth(authctxt) == 1)
+		if (privsep_preauth(authctxt) == 1) {
+			if (use_obfuscation)
+				sshpkt_disable_obfuscation();
 			goto authenticated;
+		}
 	} else if (compat20 && have_agent) {
 		if ((r = ssh_get_authentication_socket(&auth_sock)) != 0) {
 			error("Unable to get agent socket: %s", ssh_err(r));
diff --git a/sshd_config b/sshd_config
index 1fadbef..a6f7d2d 100644
--- a/sshd_config
+++ b/sshd_config
@@ -11,6 +11,8 @@
 # default value.
 
 #Port 22
+#ObfuscatedPort 222
+#ObfuscateKeyword key
 #AddressFamily any
 #ListenAddress 0.0.0.0
 #ListenAddress ::
